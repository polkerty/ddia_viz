<html>

<head>
    <style>
        .topology {
            display: flex;
            align-items: center;
            justify-content: center;
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .topology__circle-root {
            border-radius: 50%;
            border: 3px solid transparent;
            box-sizing: border-box;
        }

        .circle {
            border-radius: 50%;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid black;
            position: absolute;
            box-sizing: border-box;
            z-index: 2;
        }

        .link {
            transform-origin: top left;
            height: 0px;
            border: 1px solid black;
            position: absolute;
            z-index: 1;
        }
    </style>

    <script>
        // Model different servers, and network connections.
        class Server {
            constructor(name) {
                if (!name) {
                    name = Math.random().toString(16).slice(2);
                }
                this.name = name;
                this.netLinks = [];
            }

            connectTo(otherServer, networkLink) {
                // TODO: check for duplicate / conflicting connections.
                // this is just a quick way to set up the topology.
                networkLink.a = this;
                networkLink.b = otherServer;
                this.netLinks.push(networkLink);
                otherServer.netLinks.push(networkLink);
            }
        }

        class NetworkLink {
            constructor(name) {
                this.name = name || Math.random().toString(16).slice(2);
                this.a = null;
                this.b = null;
            }
        }

        class DatabaseNode extends Server {

        }

        class GossipProtocolNode extends Server {
            constructor(name) {
                super(name);
            }
        }

        class TopologyRenderer {
            /*
                servers: Server[]
                links: NetworkLink[]
                options: { layout: 'circle' }
            */
            constructor(servers, links, options) {
                this.servers = servers;
                this.links = links;

                this.options = Object.assign({
                    layout: 'circle',
                    domRoot: undefined
                },
                    options,
                );

                if (!this.options.domRoot) {
                    throw new Error("Must provide options.domRoot.");
                }
            }

            render() {
                switch (this.options.layout) {
                    case 'circle':
                        return this.renderCircle();
                        break;
                    default:
                        throw new Error("Non-supported layout strategy: " + this.options.layout)
                }
            }

            // translate coordinates that are centered about (0, 0)
            // to CSS positioning coordinates - (left, bottom)
            translateCoords([x, y], frameWidth, frameHeight) {
                return [x + frameWidth / 2, y + frameHeight / 2];
            }

            circleBottomLeft([x, y], diameter) {
                return [x - diameter / 2, y - diameter / 2];
            }

            renderCircle() {
                // layout the servers in a circle.
                let html = '';

                const greatCircleDiameter = 100 + 50 * this.servers.length;
                const smallCircleDiameter = 120;
                const frameSize = greatCircleDiameter + smallCircleDiameter;

                const centerCoordinatesByServerName = {};

                const [gx, gy] = this.translateCoords(
                        this.circleBottomLeft([0, 0], greatCircleDiameter),
                        frameSize,
                        frameSize
                    );

                html += `<div class="topology" style="width:${frameSize}px; height: ${frameSize}px">`;
                html += `<div class="topology__circle-root" style="width:${greatCircleDiameter}px; height: ${greatCircleDiameter}px; left: ${gx}px; bottom: ${gy}px;">`;
                for (let i = 0; i < this.servers.length; ++i) {
                    // determine the coordinates of this server.
                    // arranged as circles spaced about the perimeter of the great circle.

                    const centerAngle = (i / this.servers.length) * 2 * Math.PI;
                    const x = Math.cos(centerAngle) * greatCircleDiameter / 2;
                    const y = Math.sin(centerAngle) * greatCircleDiameter / 2;

                    centerCoordinatesByServerName[this.servers[i].name] = [x, y];

                    const [dx, dy] = this.translateCoords(
                        this.circleBottomLeft([x, y], smallCircleDiameter),
                        frameSize,
                        frameSize
                    );

                    html += `<div class="server circle" style="left: ${dx}px; bottom: ${dy}px; width: ${smallCircleDiameter}px; height: ${smallCircleDiameter}px">`;
                    html += this.servers[i].name;
                    html += '</div>';

                }

                // now to draw the network links. 
                for ( const link of this.links) {
                    // Draw a line from the center of a's circle to the center of b's circle.
                    // (but, ends at the edges of the circles.)

                    const [ax, ay] = centerCoordinatesByServerName[link.a.name], [bx, by] = centerCoordinatesByServerName[link.b.name];

                    const m = (ay - by) / (ax - bx);
                    // y = m(x - ax) + ay
                    // y = mx - max + ay
                    // b = ay - m * ax
                    const b = ay - (m * ax);

                    // what is the angle between the two?
                    const [lx, ly] = ax < bx ? [ax, ay] : [bx, by];
                    const [rx, ry] = ax < bx ? [bx, by] : [ax, ay];


                    const opposite = Math.abs(ry - ly);
                    const hypotenuse = Math.sqrt((ax - bx)*(ax - bx) + (ay - by)*(ay - by));
                    let angle = Math.asin(opposite/hypotenuse);

                    if ( ly < ry ) {
                        angle = -angle;
                    }
                    angle = Math.round(angle * 1000) / 1000;

                    const [dx, dy] = this.translateCoords(
                        [lx, ly],
                        frameSize,
                        frameSize
                    );

                    html += `<div class='link' data-id="${link.name}" style="transform: rotate(${angle}rad); width: ${Math.round(hypotenuse)}px; left: ${dx}px; bottom: ${dy}px;" ></div>`

                }

                html += '</div>';

                this.options.domRoot.innerHTML = html;

            }


        }


        // A gossip protocol
        function main() {
            gossipers = [];
            links = [];

            for (let i = 0; i < 10; ++i) {
                gossipers.push(new GossipProtocolNode());
            }

            // topology: random connections. 
            for (const gossiper of gossipers) {
                // fully connected
                for (var i = 0; i < gossipers.length; ++i) {
                    other = gossipers[i];
                    if ( other === gossiper) continue;
                    link = new NetworkLink();
                    gossiper.connectTo(other, link);
                    links.push(link);
                }
                // random links
                // for (var i = 0; i < 1; ++i) {
                //     link = new NetworkLink();
                //     other = gossipers[Math.random() * gossipers.length | 0];
                //     gossiper.connectTo(other, link);
                //     links.push(link);
                // }
            }

            console.log(gossipers);

            renderer = new TopologyRenderer(gossipers, links, {
                domRoot: document.getElementById('topology-root'),
                layout: 'circle'
            })
            renderer.render();

        }


    </script>
</head>

<body>

    <div id="topology-root">

    </div>

    <script>
        main();
    </script>
</body>

</html>